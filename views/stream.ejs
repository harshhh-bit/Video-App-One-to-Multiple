<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>Group Video Call</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/css/materialize.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.5/socket.io.js" integrity="sha512-2rUSTSAeOO02jF6eBqENNqPs1EohenJ5j+1dgDPdXSLz9nOlrr8DJk4zW/lDy8rjhGCSonW3Gx812XJQIKZKJQ==" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="/css/style.css">


</head>

<body>
    <div class="main-wrap">
        <div class="call-wrap card" style="z-index: 99">
            <a id='meetingid' href="#" style="color: black;"></a>
            <div class="remote-video-wrap" id="remote-video" style="margin-bottom:0;background-color:rgb(131 131 131); display: flex;flex-wrap: wrap;">
            </div>
            <a href="/">Leave</a>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="/js/materialize.min.js"></script>
    <script src="/js/client.js"></script>
    <script>
        var rtpAudioSenders = [];
        var rtpVideoSenders = [];

        var socketUrl = 'http://localhost:3000';
        var username = "<%= username %>";
        var meeting_id = "<%= meeting_id %>"; 
        var is_host = "<%= is_host %>";
        var localUserVideo;
        var remoteStream = [];
        var audioStream = [];
        var audioTrack;
        var mediaTrack;
        var users_connectionID = [];
        var users_connection = [];
        var sdpFunction;
        sdpFunction = (data, to_connid) => {
            socket.emit('sdpProcess', {
                message: data,
                to_connid: to_connid
            });
        }

        var socket = io.connect(socketUrl); //passing socketUrl is optional
        
        socket.on("connect", () => {
            if(socket.connected) { // boolean that indicates whether the client is currently connected to the server
                socket.emit("users_info_to_signaling_server", {
                    current_user_name: username,
                    meeting_id: meeting_id,
                    is_host: is_host
                });
            }

            localConnectionID = socket.id;
            localUserVideo = document.getElementById("localStream");
            processMedia();
        });
    
        socket.on('newConnectionInformation', function(other_users) {
            $('#remote-video .other').remove();
            
            for(let i = 0; i < other_users.length; i++) {
                //console.log(other_users[i].is_host);
                if(other_users[i].is_host == "true") {
                    addUser(other_users[i].user_id, other_users[i].is_host, other_users[i].connectionId);
                    createConnection(other_users[i].connectionId, other_users[i].is_host);
                }
            }
        });

        socket.on('other_users_to_inform', function(data) {
            // console.log(other_users[i].is_host);
            // if(data.other_user_is_host) {
                //addUser(data.other_user_id, data.other_user_is_host, data.connId);
                createConnection(data.connId, data.other_user_is_host);
            //}
        });

        function addUser(other_username, other_is_host, connId) { // need update
            $('#remote-video').append(`
                <div id="` + connId + `" class="remote-user other div-center-column">
                    <h5 class="div-center">` + other_username + `</h5>
                    <div class="div-center">
                        <video autoplay id="video_` + connId + `"></video>
                        <audio autoplay id="audio_` + connId + `"></audio>
                    </div>
                </div>
            `);
        }

        function updateMediaSenders(track, rtpSenders) { // rtpSender => other users
            for(var connId in users_connection) {
                var connections = users_connection[connId];
                if(connections && (connections.connectionState == "new" || 
                connections.connectionState == "connecting" || 
                connections.connectionState == "connected")) {
                    if(rtpSenders[connId] && rtpSenders[connId].track) {
                        rtpSenders[connId].replaceTrack(track);
                    }
                    else {
                        rtpSenders[connId] = users_connection[connId].addTrack(track);
                    }
                }
            }
        }
        
        var iceConfig = {
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                },
                {
                    urls: 'stun:stun1.l.google.com:3478'
                },
                {
                    urls: 'stun:stun2.l.google.com:19302'
                },
                {
                    urls: 'stun:stun3.l.google.com:3478'
                },
                {
                    urls: 'stun:stun4.l.google.com:19302'
                }
            ]
         }

        async function createConnection(connId, is_host) {
            var connection = new RTCPeerConnection(iceConfig); // iceConfig: for ice candidate exchange
        
            connection.onicecandidate = function(event) {
                if(event.candidate) {
                    sdpFunction(JSON.stringify({
                        'iceCandidate': event.candidate
                    }), connId);
                }
            }
            connection.onnegotiationneeded = async function(event) {
                await createOffer(connId);
            }

            connection.ontrack = function(event) {
                if(!remoteStream[connId]) {
                    remoteStream[connId] = new MediaStream();
                }

                if(!audioStream[connId]) {
                    audioStream[connId] = new MediaStream();
                }

                if(event.track.kind == 'video' && is_host == 'true') {
                    remoteStream[connId].getTracks().forEach(t => remoteStream[connId].removeTrack(t));
                    
                    remoteStream[connId].addTrack(event.track);

                    var remoteVideoDiv = document.getElementById('video_'+connId);
                    remoteVideoDiv.srcObject = null;
                    remoteVideoDiv.srcObject = remoteStream[connId];
                    remoteVideoDiv.load();
                }
                else if(event.track.kind == 'audio' && is_host == 'true') {
                    audioStream[connId].getTracks().forEach(t => audioStream[connId].removeTrack(t));
                    audioStream[connId].addTrack(event.track);
   
                    var remoteAudioDiv = document.getElementById('audio_'+connId);
                    remoteAudioDiv.srcObject = null;
                    remoteAudioDiv.srcObject = audioStream[connId];
                    remoteAudioDiv.load();
                }
            }

            users_connectionID[connId] = connId;
            users_connection[connId] = connection;

            updateMediaSenders(mediaTrack, rtpVideoSenders);
        
            return connection;
        }
        
        async function createOffer(connid) {
            var connection = users_connection[connid];
            var offer = await connection.createOffer();

            await connection.setLocalDescription(offer);
            
            sdpFunction(JSON.stringify({
                'offer': connection.localDescription
            }), connid);
        }

        socket.on('sdpProcess', async function(data) {
            await sdpProcess(data.message, data.from_connid);
        });

        async function processMedia() {
            try {
                if(is_host == 'true') {
                    var vStream = null;
                    var aStream = null;

                    vStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width:720,
                            height:480
                        },
                        audio: false
                    });

                    aStream = await navigator.mediaDevices.getUserMedia({
                        video: false,
                        audio: true
                    });

                    audioTrack = aStream.getAudioTracks()[0]; // contains audio
                    audioTrack.enable = true;
                    updateMediaSenders(audioTrack, rtpAudioSenders);
                
                    mediaTrack = vStream.getVideoTracks()[0]; // contains video
                    localUserVideo.srcObject = new MediaStream([mediaTrack]);
                    updateMediaSenders(mediaTrack, rtpVideoSenders);
                }
            }
            catch(err) {
                console.log(err);
            }
        }

        async function sdpProcess(message, from_connid) {
            message = JSON.parse(message);

            if(message.answer) {
                await users_connection[from_connid].setRemoteDescription(new RTCSessionDescription(message.answer));
            }
            else if(message.offer) {
                if(!users_connection[from_connid])
                    await createConnection(from_connid);

                    await users_connection[from_connid].setRemoteDescription(new RTCSessionDescription(message.offer));
                    var answer = await users_connection[from_connid].createAnswer();
                    
                    await users_connection[from_connid].setLocalDescription(answer);

                    sdpFunction(JSON.stringify({
                        'answer': answer
                    }), from_connid);
            }
            else if(message.iceCandidate) {
                if(!users_connection[from_connid])
                    await createConnection(from_connid);

                try {

                    await users_connection[from_connid].addIceCandidate(message.iceCandidate);

                } 
                catch(error) {
                    console.log(error);
                }
            }
        }

        socket.on('closedConnectionInfo', function(connId) {
            $('#'+connId).remove();
            users_connectionID[connId] = null;
            users_connection[connId].close();
            users_connection[connId] = null;
            if(remoteStream[connId]) {
                remoteStream[connId].getTracks().forEach(t => {
                    t.stop();
                });

                remoteStream[connId] = null;
            }
        });
    </script>

</body>

</html>